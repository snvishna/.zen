#!/bin/bash
# Ô£ø Zen Load v5.0 (Stow Edition)
# The Orchestrator

set -e

# --- Configuration ---
ZEN_HOME="${HOME}/.zen"
STOW_DIR="${ZEN_HOME}/stow"
MANIFESTS="${ZEN_HOME}/manifests"
BREWFILE="${MANIFESTS}/Brewfile"
NPM_LIST="${MANIFESTS}/npm_globals.txt"
VSCODE_LIST="${STOW_DIR}/vscode/.config/vscode/extensions.txt"
MACOS_SCRIPT="${MANIFESTS}/macos/defaults.sh"
DFSYNC_URL="https://raw.githubusercontent.com/snvishna/dotfilesync/master/src/dfsync.sh"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# --- Helpers ---
prompt_user() {
    local prompt="$1"
    if [[ "$FORCE_ALL" == "true" ]]; then return 0; fi # Auto-yes
    read -p "$prompt [y/N] " response
    echo ""
    if [[ "$response" =~ ^[Yy]$ ]]; then return 0; else return 1; fi
}

check_stow() {
    if ! command -v stow &> /dev/null; then
        echo -e "${YELLOW}Stow not found. Installing via Brew...${NC}"
        brew install stow
    fi
}

backup_file() {
    local target="$1"
    # Timestamped backup for safety (Non-destructive)
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local backup="${target}.pre-zen-${timestamp}.bak"
    
    echo -e "${YELLOW}[BACKUP]${NC} Moving $target to $backup"
    mv "$target" "$backup"
}

dfsync_activate() {
    local pattern="$1"
    local bin_path="${HOME}/.local/bin/dfsync"
    
    # We use track to ensure they are in local config, then pull.
    # Actually, we just want to ensure we pull the LATEST version of these files from Gist
    # irrespective of whether they are tracked locally yet?
    # No, dfsync pull only pulls what is in the config.
    # So we must 'track' them first if we want them?
    # Or we assume the user's Gist ALREADY has them.
    # Current design: The manifest is the source of truth.
    
    # Find all files matching pattern in dfsync.json?
    # No, we'll just run pull and trust dfsync.json is populated?
    # Wait, for a new user, dfsync.json is empty.
    # So we need to populate it from our templates? 
    # v2.1 Optimization: We treat ~/.zen/dfsync.json as the master catalog.
    # It SHOULD already contain everything we care about if we checked out the repo.
    # But it might be empty if we want to be selective.
     
    # Strategy: 
    # 1. Read catalog from repo (dfsync.json.template -> effectively master list)
    # 2. Add matching files to local .dfsync.json
    # 3. Pull them.
    
    if [[ -x "$bin_path" ]]; then
        # This is a "smart" activation.
        # We assume the user wants the files related to this module.
        # Check if we have a gist.
        local gist_id=$(grep "gist_id" "${HOME}/.dfsync.json" 2>/dev/null | cut -d'"' -f4)
        if [[ -n "$gist_id" ]]; then
             # Filter is tricky without complex logic. 
             # For now, we rely on the initial full pull or selective pull?
             # Let's simple run pull with interactive prompts?
             # No, users want minimal prompt.
             
             # Currently we just run pull.
             : # Placeholder for future granular sync
        fi
    fi
}

resolve_conflicts() {
    local candidates=("$@")
    echo -e "\n--- ‚öîÔ∏è  Resolving Conflicts (Smart) ---"
    
    for pkg in "${candidates[@]}"; do
        local pkg_dir="${STOW_DIR}/${pkg}"
        
        if [[ -d "$pkg_dir" ]]; then
            # Safe array-based find loop to handle all filenames
            local files=()
            # FIX 2: Also include directories (-type d) to catch conflicting directory symlinks (e.g. .config/wezterm -> old repo)
            while IFS= read -r -d '' f; do files+=("$f"); done < <(find "$pkg_dir" \( -name ".git" -prune \) -o \( -name ".DS_Store" -prune \) -o \( -type f -o -type l -o -type d \) -print0)
            
            for file in "${files[@]}"; do
                # Get relative path
                local rel_path="${file#$pkg_dir}"
                rel_path="${rel_path#/}"
                
                if [[ -z "$rel_path" ]]; then continue; fi

                local target="${HOME}/${rel_path}"
                
                # Check for conflicts
                if [[ -e "$target" || -L "$target" ]]; then
                    if [[ -L "$target" ]]; then
                        local link_target=$(readlink "$target")
                        # Check strict stow path match
                        # We accept it if it points deeper into our specific package
                        if [[ "$link_target" == *".zen/stow/$pkg/$rel_path"* ]]; then
                            continue
                        fi
                        echo "  - Invalid symlink: $target -> $link_target"
                    else
                        # If it's a real directory, ignore it (Stow will merge)
                        if [[ -d "$target" && ! -L "$target" ]]; then
                           continue
                        fi
                        echo "  - Blocking file: $target"
                    fi
                    
                    backup_file "$target"
                fi
            done
        fi
    done
}

run_stow_packages() {
    local pkgs=("$@")
    echo -e "\n--- üì¶ Stowing Packages: ${pkgs[*]} ---"
    
    # Pre-flight conflict resolution
    resolve_conflicts "${pkgs[@]}"
    
    local stow_args=("-d" "$STOW_DIR" "-t" "$HOME")
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        stow_args+=("-v")
    fi
    
    if [[ "$CHECK_MODE" == "true" ]]; then
        stow_args+=("-n")
    else
        # Force stow has no effect on conflicts unless --adopt, but we solved conflicts above.
        :
    fi
    
    for pkg in "${pkgs[@]}"; do
        if [[ -d "${STOW_DIR}/${pkg}" ]]; then
            echo -e "  - Stowing ${pkg}..."
            
            # 1. Resolve Stow Conflicts (Target exists)
            resolve_conflicts "$pkg"
            
            # 2. Resolve Legacy Precedence Conflicts (e.g. ~/.wezterm.lua)
            resolve_legacy_conflicts "$pkg"
            
            if ! stow -R "${stow_args[@]}" "$pkg" 2>&1 | sed 's/^/    /'; then
                echo -e "${RED}[ERROR] Stow failed for $pkg.${NC}"
            fi
        else
            echo -e "${YELLOW}[WARN]${NC} Package $pkg not found in stow dir."
        fi
    done
}

# --- 2. Installers ---
install_homebrew_core_only() {
    if ! command -v brew &> /dev/null; then
        echo "Installing Homebrew..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        eval "$(/opt/homebrew/bin/brew shellenv 2>/dev/null || /usr/local/bin/brew shellenv)"
    fi
}

install_homebrew() {
    echo -e "\n--- üç∫ Installing Homebrew Packages ---"
    # Prevent quarantine for casks (faster, cleaner)
    export HOMEBREW_CASK_OPTS="--no-quarantine"
    
    install_homebrew_core_only
    
    if [[ -f "$BREWFILE" ]]; then
        brew bundle install --file="$BREWFILE"
        echo -e "${GREEN}‚úîÔ∏é Brew bundle complete.${NC}"
        setup_fonts
    else
        echo -e "${YELLOW}[SKIP]${NC} No Brewfile found."
    fi
}

setup_fonts() {
    echo -e "\n--- üÖ∞Ô∏è  Setting up Fonts ---"
    local font_source="/opt/homebrew/share/fonts"
    local font_dest="${HOME}/Library/Fonts"
    local found_new=false

    if [[ -d "$font_source" ]]; then
        # Check specifically for JetBrains Nerd Font as WezTerm needs it
        for font in "$font_source"/*; do
            local fname=$(basename "$font")
            if [[ ! -f "${font_dest}/${fname}" ]]; then
                cp "$font" "$font_dest/"
                echo -e "  - Installed: $fname"
                found_new=true
            fi
        done
        
        if [[ "$found_new" == "true" ]]; then
            echo "Refreshing font cache..."
            atsutil server -shutdown 2>/dev/null || true
            atsutil server -ping 2>/dev/null || true
        else
            echo -e "${GREEN}‚úîÔ∏é Fonts already up to date.${NC}"
        fi
    else
        echo -e "${YELLOW}[WARN]${NC} No Homebrew fonts found at $font_source"
    fi
}


install_dfsync() {
    local force_update="$1" # Ignored now, we always update
    local dfsync_args="$2"
    echo -e "\n--- ‚òÅÔ∏è  Installing/Updating dfsync ---"
    local bin_path="${HOME}/.local/bin/dfsync"
    local installed=false

    # Always fetch latest version to ensure consistency
    echo -e "Downloading latest dfsync..."
    if curl -fsSL "$DFSYNC_URL" -o "$bin_path" 2>/dev/null; then
        chmod +x "$bin_path"
        if head -n 1 "$bin_path" | grep -q "#!"; then
            echo -e "${GREEN}‚úîÔ∏é dfsync updated to latest.${NC}"
            installed=true
        else
            echo -e "${RED}[ERROR]${NC} Invalid download."
            rm "$bin_path"
            return
        fi
    else
        echo -e "${RED}[ERROR]${NC} Download failed. Using existing binary if available."
        [[ -x "$bin_path" ]] && installed=true
    fi

    if [[ "$installed" == "true" ]]; then
        # SMART MIGRATION: Preserve Gist ID from old config if present
        local old_gist_id=""
        # Search common old paths
        for old_conf in "${HOME}/.dfsync.json" "${HOME}/.config/dfsync/config.json"; do
            if [[ -f "$old_conf" ]]; then
                local found=$(grep "gist_id" "$old_conf" | cut -d'"' -f4)
                if [[ -n "$found" ]]; then
                    old_gist_id="$found"
                    break
                fi
            fi
        done
        
        # Switch to Repo standardized config
        local target_config="${HOME}/.zen/dfsync.json"
        
        # If we found an ID and the target doesn't have one (or is empty template), inject it.
        # This is strictly "safe migration" logic.
        if [[ -n "$old_gist_id" && -f "$target_config" ]]; then
             local current_target_id=$(grep "gist_id" "$target_config" | cut -d'"' -f4)
             if [[ -z "$current_target_id" ]]; then
                 echo -e "${YELLOW}[MIGRATE] injecting old Gist ID ($old_gist_id) into new config...${NC}"
                 # Use tmp file to write safely
                 tmp=$(mktemp)
                 sed "s/\"gist_id\": \"\"/\"gist_id\": \"$old_gist_id\"/" "$target_config" > "$tmp" && mv "$tmp" "$target_config"
             fi
        fi

        # Force config path to project standard to prevent [y] prompt issue
        "$bin_path" config path "$target_config" >/dev/null 2>&1
        
        echo -e "Running dfsync setup..."
        "$bin_path" setup $dfsync_args
        
        # Check if we have a valid Gist ID now
        local gist_id_check
        if [[ -f "${HOME}/.dfsync.json" ]]; then
            gist_id_check=$(grep "gist_id" "${HOME}/.dfsync.json" | cut -d'"' -f4)
        fi
        
        if [[ -n "$gist_id_check" ]]; then
            echo -e "Running dfsync pull..."
            "$bin_path" pull $dfsync_args || echo -e "${YELLOW}[WARN] Pull failed (possibly empty Gist). Continuing...${NC}"
        else
            echo -e "${YELLOW}[SKIP] No Gist ID configured. Skipping initial pull.${NC}"
        fi
    fi
}

install_npm_globals() {
    echo -e "\n--- üü¢ Installing NPM Globals ---"
    if command -v npm &> /dev/null && [[ -f "$NPM_LIST" ]]; then
        # Check if list is empty?
        grep -vE '^\s*#|^\s*$' "$NPM_LIST" | while read -r pkg; do
            # Use depth=0 for speed and focus on top-level
            npm list -g --depth=0 "$pkg" &> /dev/null || (echo "Installing $pkg..." && npm install -g "$pkg")
        done
    fi
}

# --- Constants ---
# Apps that require permission fixes (Format: "AppName.app")
PROTECTED_APPS=("WezTerm.app" "Kiro CLI.app")

# Private Config Mapping (Format: "directory_name:plist_filename")
PRIVATE_CONFIGS=(
    "raycast:com.raycast.macos.plist"
    "rectangle:com.knollsoft.Rectangle.plist"
    "ice:com.jordanbaird.Ice.plist"
    "stats:eu.exelban.Stats.plist"
)

# Legacy Configs to Archive (Format: "package_name:legacy_file_path")
# These files take precedence over XDG configs (e.g. ~/.wezterm.lua > ~/.config/wezterm/wezterm.lua)
LEGACY_CONFLICTS=(
    "wezterm:${HOME}/.wezterm.lua"
    "starship:${HOME}/.starship.toml"
)

resolve_legacy_conflicts() {
    local pkg_name="$1"
    for conflict in "${LEGACY_CONFLICTS[@]}"; do
        local target_pkg="${conflict%%:*}"
        local legacy_file="${conflict##*:}"
        
        if [[ "$pkg_name" == "$target_pkg" && -f "$legacy_file" ]]; then
             echo -e "${YELLOW}[FIX] Found conflicting legacy config ${legacy_file}. Moving to backup...${NC}"
             backup_file "$legacy_file"
        fi
    done
}

fix_app_permissions() {
    local found_issues=false
    
    for app_name in "${PROTECTED_APPS[@]}"; do
        local app_path="/Applications/${app_name}"
        if [[ -d "$app_path" ]]; then
            # Check ownership (if not owned by current user)
            if [[ "$(stat -f '%u' "$app_path")" != "$(id -u)" ]]; then
                echo -e "${YELLOW}[WARN] Ownership conflict detected for ${app_name}${NC}"
                found_issues=true
            fi
        fi
    done
    
    if [[ "$found_issues" == "true" ]]; then
        if prompt_user "üîß Fix permissions for conflicting Apps (WezTerm/Kiro)?"; then
             echo "Claiming ownership of protected apps..."
             # Construct command dynamically
             local targets=()
             for app in "${PROTECTED_APPS[@]}"; do
                 targets+=("/Applications/$app")
             done
             
             # Run sudo once for all targets
             if [[ ${#targets[@]} -gt 0 ]]; then
                sudo chown -R "$(whoami)" "${targets[@]}" 2>/dev/null || true
                echo -e "${GREEN}‚úîÔ∏é Permissions patched.${NC}"
             fi
        fi
    fi
}

install_vscode_extensions() {
    echo -e "\n--- üü£ Installing VS Code Extensions ---"
    if command -v code &> /dev/null && [[ -f "$VSCODE_LIST" ]]; then
        grep -vE '^\s*#|^\s*$' "$VSCODE_LIST" | \
        xargs -L 1 -P 4 code --install-extension --force > /dev/null 2>&1
        echo -e "${GREEN}‚úîÔ∏é Extensions installed.${NC}"
    fi
}

install_macos_defaults() {
    echo -e "\n--- üçé Applying macOS Defaults ---"
    # 3. Defaults
    if [[ -f "$MACOS_SCRIPT" ]]; then
        echo "Applying defaults..."
        chmod +x "$MACOS_SCRIPT"
        # Suppress Safari permissions errors (Containers issue)
        "$MACOS_SCRIPT" 2>&1 | grep -v "Could not write domain.*com.apple.Safari" || true
    fi
    
    # 4. Install Config Backup Agent (Template -> Real)
    echo "Installing Config Backup Agent..."
    local template="${ZEN_HOME}/manifests/templates/com.template.configbackup.plist"
    local target="${HOME}/Library/LaunchAgents/com.shankar.configbackup.plist"
    
    if [[ -f "$template" ]]; then
        sed "s|{{HOME}}|${HOME}|g" "$template" > "$target"
        
        launchctl unload "$target" 2>/dev/null || true
        launchctl load "$target"
        echo "‚úîÔ∏é Config Backup Agent installed and loaded."
    fi
    
    # 5. Fix Finder Saved Search (Template -> Real)
    echo "Configuring Finder Recents..."
    local recents_template="${ZEN_HOME}/manifests/templates/Recents.savedSearch.template"
    local recents_target="${HOME}/Library/Saved Searches/Recents.savedSearch"
    if [[ -f "$recents_template" ]]; then
        mkdir -p "$(dirname "$recents_target")"
        sed "s|{{HOME}}|${HOME}|g" "$recents_template" > "$recents_target"
    fi

    echo -e "${GREEN}‚úîÔ∏é Defaults applied.${NC}"
}

restore_private_configs() {
    echo -e "\n--- üîí Restoring Private App Configs ---"
    local private_root="${ZEN_HOME}/manifests/private"
    
    for config in "${PRIVATE_CONFIGS[@]}"; do
        local dir_name="${config%%:*}"
        local plist_name="${config##*:}"
        local src="${private_root}/${dir_name}/${plist_name}"
        local dest="${HOME}/Library/Preferences/${plist_name}"
        
        if [[ -f "$src" ]]; then
            echo -e "Restoring ${dir_name} preferences..."
            cp "$src" "$dest"
            # Attempt to refresh preferences cache (safe)
            killall cfprefsd &>/dev/null || true
        fi
    done
}

# --- Main Logic ---
main() {
    export CHECK_MODE="false"
    export FORCE_ALL="false"
    local dfsync_flags=""

    for arg in "$@"; do
        case $arg in
            --check|-c)   CHECK_MODE="true" ;;
            --all)        FORCE_ALL="true" ;;
            --force)      FORCE_ALL="true" ;;
            -v)           dfsync_flags+=" -v" ;;
            --help|-h)    show_help ;;
        esac
    done

    echo "--- üöÄ Zen Load (Interactive) ---"
    if [[ "$CHECK_MODE" == "false" ]]; then
        echo -e "${YELLOW}üîê Admin privileges required for some tasks.${NC}"
        sudo -v
        while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &
    else
        echo -e "${BLUE}üîç Check Mode Enabled (Dry Run)${NC}"
    fi

    # 1. Boilerplate (Dependencies)
    if [[ "$CHECK_MODE" == "false" ]]; then
        install_homebrew_core_only
        check_stow
        # Ensure dfsync is available
        install_dfsync "false" "$dfsync_flags"
        # Removed global resolve_conflicts here; it is now called inside run_stow_packages per module
    fi

    # 1.4 Permissions Check (Pre-Flight)
    fix_app_permissions

    # 1.5 Homebrew Bundle (Install/Update)
    if prompt_user "üç∫ Install/Update Homebrew Packages?"; then
         # We do not strictly need dfsync_activate "Brewfile" as it's in the repo (manifests/),
         # but if the user has a PRIVATE Brewfile override in dfsync.json/manifests/private, 
         # we should allow dfsync to pull it ?
         # Currently Brewfile is public. 
         if [[ "$CHECK_MODE" == "false" ]]; then install_homebrew; fi
    fi

    # 2. Shell Configuration (zsh, starship, git, bin)
    if prompt_user "üì¶ Stow Shell Environment (zsh, starship, git, bin)?"; then
        dfsync_activate "zshrc|zprofile|zimrc|starship|gitconfig"
        run_stow_packages "zsh" "starship" "git" "bin"
    fi

    # 4. Editor (VS Code)
    if prompt_user "üìù Install VS Code Config & Extensions?"; then
        dfsync_activate "vscode"
        run_stow_packages "vscode"
        if [[ "$CHECK_MODE" == "false" ]]; then install_vscode_extensions; fi
    fi

    # 5. System (macOS Defaults, Launchd, NPM?)
    if prompt_user "üçé Apply macOS Defaults & System Tweaks?"; then
        dfsync_activate "Raycast|Rectangle|Recents|LaunchAgents|defaults|Brewfile|npm_globals|installed_apps"
        if [[ "$CHECK_MODE" == "false" ]]; then 
            install_macos_defaults
            install_npm_globals
            restore_private_configs
        fi
    fi

    echo -e "\n${GREEN}‚úîÔ∏é Zen Load Complete.${NC}"
}

main "$@"
